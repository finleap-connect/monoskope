// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package domain

import (
	context "context"
	audit "github.com/finleap-connect/monoskope/pkg/api/domain/audit"
	projections "github.com/finleap-connect/monoskope/pkg/api/domain/projections"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	// GetAll returns all users.
	GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (User_GetAllClient, error)
	// GetById returns the user found by the given id.
	GetById(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*projections.User, error)
	// GetByEmail returns the user found by the given email address.
	GetByEmail(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*projections.User, error)
	// GetRoleBindingsById returns all role bindings related to the given user id.
	GetRoleBindingsById(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (User_GetRoleBindingsByIdClient, error)
	// GetCount returns the count of users
	GetCount(ctx context.Context, in *GetCountRequest, opts ...grpc.CallOption) (*GetCountResult, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (User_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &User_ServiceDesc.Streams[0], "/domain.User/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &userGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type User_GetAllClient interface {
	Recv() (*projections.User, error)
	grpc.ClientStream
}

type userGetAllClient struct {
	grpc.ClientStream
}

func (x *userGetAllClient) Recv() (*projections.User, error) {
	m := new(projections.User)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userClient) GetById(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*projections.User, error) {
	out := new(projections.User)
	err := c.cc.Invoke(ctx, "/domain.User/GetById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetByEmail(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*projections.User, error) {
	out := new(projections.User)
	err := c.cc.Invoke(ctx, "/domain.User/GetByEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetRoleBindingsById(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (User_GetRoleBindingsByIdClient, error) {
	stream, err := c.cc.NewStream(ctx, &User_ServiceDesc.Streams[1], "/domain.User/GetRoleBindingsById", opts...)
	if err != nil {
		return nil, err
	}
	x := &userGetRoleBindingsByIdClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type User_GetRoleBindingsByIdClient interface {
	Recv() (*projections.UserRoleBinding, error)
	grpc.ClientStream
}

type userGetRoleBindingsByIdClient struct {
	grpc.ClientStream
}

func (x *userGetRoleBindingsByIdClient) Recv() (*projections.UserRoleBinding, error) {
	m := new(projections.UserRoleBinding)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userClient) GetCount(ctx context.Context, in *GetCountRequest, opts ...grpc.CallOption) (*GetCountResult, error) {
	out := new(GetCountResult)
	err := c.cc.Invoke(ctx, "/domain.User/GetCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
	// GetAll returns all users.
	GetAll(*GetAllRequest, User_GetAllServer) error
	// GetById returns the user found by the given id.
	GetById(context.Context, *wrapperspb.StringValue) (*projections.User, error)
	// GetByEmail returns the user found by the given email address.
	GetByEmail(context.Context, *wrapperspb.StringValue) (*projections.User, error)
	// GetRoleBindingsById returns all role bindings related to the given user id.
	GetRoleBindingsById(*wrapperspb.StringValue, User_GetRoleBindingsByIdServer) error
	// GetCount returns the count of users
	GetCount(context.Context, *GetCountRequest) (*GetCountResult, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) GetAll(*GetAllRequest, User_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedUserServer) GetById(context.Context, *wrapperspb.StringValue) (*projections.User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetById not implemented")
}
func (UnimplementedUserServer) GetByEmail(context.Context, *wrapperspb.StringValue) (*projections.User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByEmail not implemented")
}
func (UnimplementedUserServer) GetRoleBindingsById(*wrapperspb.StringValue, User_GetRoleBindingsByIdServer) error {
	return status.Errorf(codes.Unimplemented, "method GetRoleBindingsById not implemented")
}
func (UnimplementedUserServer) GetCount(context.Context, *GetCountRequest) (*GetCountResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCount not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAllRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserServer).GetAll(m, &userGetAllServer{stream})
}

type User_GetAllServer interface {
	Send(*projections.User) error
	grpc.ServerStream
}

type userGetAllServer struct {
	grpc.ServerStream
}

func (x *userGetAllServer) Send(m *projections.User) error {
	return x.ServerStream.SendMsg(m)
}

func _User_GetById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.User/GetById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetById(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.User/GetByEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetByEmail(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetRoleBindingsById_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserServer).GetRoleBindingsById(m, &userGetRoleBindingsByIdServer{stream})
}

type User_GetRoleBindingsByIdServer interface {
	Send(*projections.UserRoleBinding) error
	grpc.ServerStream
}

type userGetRoleBindingsByIdServer struct {
	grpc.ServerStream
}

func (x *userGetRoleBindingsByIdServer) Send(m *projections.UserRoleBinding) error {
	return x.ServerStream.SendMsg(m)
}

func _User_GetCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.User/GetCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetCount(ctx, req.(*GetCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "domain.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetById",
			Handler:    _User_GetById_Handler,
		},
		{
			MethodName: "GetByEmail",
			Handler:    _User_GetByEmail_Handler,
		},
		{
			MethodName: "GetCount",
			Handler:    _User_GetCount_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _User_GetAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetRoleBindingsById",
			Handler:       _User_GetRoleBindingsById_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/domain/queryhandler_service.proto",
}

// TenantClient is the client API for Tenant service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TenantClient interface {
	// GetAll returns all tenants.
	GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (Tenant_GetAllClient, error)
	// GetById returns the tenant found by the given id.
	GetById(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*projections.Tenant, error)
	// GetByName returns the tenant found by the given name
	GetByName(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*projections.Tenant, error)
	// GetUsers returns users belonging to the given tenant id.
	GetUsers(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (Tenant_GetUsersClient, error)
}

type tenantClient struct {
	cc grpc.ClientConnInterface
}

func NewTenantClient(cc grpc.ClientConnInterface) TenantClient {
	return &tenantClient{cc}
}

func (c *tenantClient) GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (Tenant_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &Tenant_ServiceDesc.Streams[0], "/domain.Tenant/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &tenantGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Tenant_GetAllClient interface {
	Recv() (*projections.Tenant, error)
	grpc.ClientStream
}

type tenantGetAllClient struct {
	grpc.ClientStream
}

func (x *tenantGetAllClient) Recv() (*projections.Tenant, error) {
	m := new(projections.Tenant)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tenantClient) GetById(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*projections.Tenant, error) {
	out := new(projections.Tenant)
	err := c.cc.Invoke(ctx, "/domain.Tenant/GetById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantClient) GetByName(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*projections.Tenant, error) {
	out := new(projections.Tenant)
	err := c.cc.Invoke(ctx, "/domain.Tenant/GetByName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantClient) GetUsers(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (Tenant_GetUsersClient, error) {
	stream, err := c.cc.NewStream(ctx, &Tenant_ServiceDesc.Streams[1], "/domain.Tenant/GetUsers", opts...)
	if err != nil {
		return nil, err
	}
	x := &tenantGetUsersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Tenant_GetUsersClient interface {
	Recv() (*projections.TenantUser, error)
	grpc.ClientStream
}

type tenantGetUsersClient struct {
	grpc.ClientStream
}

func (x *tenantGetUsersClient) Recv() (*projections.TenantUser, error) {
	m := new(projections.TenantUser)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TenantServer is the server API for Tenant service.
// All implementations must embed UnimplementedTenantServer
// for forward compatibility
type TenantServer interface {
	// GetAll returns all tenants.
	GetAll(*GetAllRequest, Tenant_GetAllServer) error
	// GetById returns the tenant found by the given id.
	GetById(context.Context, *wrapperspb.StringValue) (*projections.Tenant, error)
	// GetByName returns the tenant found by the given name
	GetByName(context.Context, *wrapperspb.StringValue) (*projections.Tenant, error)
	// GetUsers returns users belonging to the given tenant id.
	GetUsers(*wrapperspb.StringValue, Tenant_GetUsersServer) error
	mustEmbedUnimplementedTenantServer()
}

// UnimplementedTenantServer must be embedded to have forward compatible implementations.
type UnimplementedTenantServer struct {
}

func (UnimplementedTenantServer) GetAll(*GetAllRequest, Tenant_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedTenantServer) GetById(context.Context, *wrapperspb.StringValue) (*projections.Tenant, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetById not implemented")
}
func (UnimplementedTenantServer) GetByName(context.Context, *wrapperspb.StringValue) (*projections.Tenant, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByName not implemented")
}
func (UnimplementedTenantServer) GetUsers(*wrapperspb.StringValue, Tenant_GetUsersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetUsers not implemented")
}
func (UnimplementedTenantServer) mustEmbedUnimplementedTenantServer() {}

// UnsafeTenantServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TenantServer will
// result in compilation errors.
type UnsafeTenantServer interface {
	mustEmbedUnimplementedTenantServer()
}

func RegisterTenantServer(s grpc.ServiceRegistrar, srv TenantServer) {
	s.RegisterService(&Tenant_ServiceDesc, srv)
}

func _Tenant_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAllRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TenantServer).GetAll(m, &tenantGetAllServer{stream})
}

type Tenant_GetAllServer interface {
	Send(*projections.Tenant) error
	grpc.ServerStream
}

type tenantGetAllServer struct {
	grpc.ServerStream
}

func (x *tenantGetAllServer) Send(m *projections.Tenant) error {
	return x.ServerStream.SendMsg(m)
}

func _Tenant_GetById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServer).GetById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.Tenant/GetById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServer).GetById(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tenant_GetByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServer).GetByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.Tenant/GetByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServer).GetByName(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tenant_GetUsers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TenantServer).GetUsers(m, &tenantGetUsersServer{stream})
}

type Tenant_GetUsersServer interface {
	Send(*projections.TenantUser) error
	grpc.ServerStream
}

type tenantGetUsersServer struct {
	grpc.ServerStream
}

func (x *tenantGetUsersServer) Send(m *projections.TenantUser) error {
	return x.ServerStream.SendMsg(m)
}

// Tenant_ServiceDesc is the grpc.ServiceDesc for Tenant service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Tenant_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "domain.Tenant",
	HandlerType: (*TenantServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetById",
			Handler:    _Tenant_GetById_Handler,
		},
		{
			MethodName: "GetByName",
			Handler:    _Tenant_GetByName_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _Tenant_GetAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUsers",
			Handler:       _Tenant_GetUsers_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/domain/queryhandler_service.proto",
}

// ClusterClient is the client API for Cluster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClusterClient interface {
	// GetAll returns all known clusters
	GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (Cluster_GetAllClient, error)
	// GetById returns a cluster by its UUID
	GetById(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*projections.Cluster, error)
	// GetByName returns a cluster by its name
	GetByName(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*projections.Cluster, error)
	// GetBootstrapToken returns the JWT token for cluster authentication for the
	// cluster with the given UUID
	GetBootstrapToken(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
}

type clusterClient struct {
	cc grpc.ClientConnInterface
}

func NewClusterClient(cc grpc.ClientConnInterface) ClusterClient {
	return &clusterClient{cc}
}

func (c *clusterClient) GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (Cluster_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &Cluster_ServiceDesc.Streams[0], "/domain.Cluster/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Cluster_GetAllClient interface {
	Recv() (*projections.Cluster, error)
	grpc.ClientStream
}

type clusterGetAllClient struct {
	grpc.ClientStream
}

func (x *clusterGetAllClient) Recv() (*projections.Cluster, error) {
	m := new(projections.Cluster)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterClient) GetById(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*projections.Cluster, error) {
	out := new(projections.Cluster)
	err := c.cc.Invoke(ctx, "/domain.Cluster/GetById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetByName(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*projections.Cluster, error) {
	out := new(projections.Cluster)
	err := c.cc.Invoke(ctx, "/domain.Cluster/GetByName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetBootstrapToken(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, "/domain.Cluster/GetBootstrapToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterServer is the server API for Cluster service.
// All implementations must embed UnimplementedClusterServer
// for forward compatibility
type ClusterServer interface {
	// GetAll returns all known clusters
	GetAll(*GetAllRequest, Cluster_GetAllServer) error
	// GetById returns a cluster by its UUID
	GetById(context.Context, *wrapperspb.StringValue) (*projections.Cluster, error)
	// GetByName returns a cluster by its name
	GetByName(context.Context, *wrapperspb.StringValue) (*projections.Cluster, error)
	// GetBootstrapToken returns the JWT token for cluster authentication for the
	// cluster with the given UUID
	GetBootstrapToken(context.Context, *wrapperspb.StringValue) (*wrapperspb.StringValue, error)
	mustEmbedUnimplementedClusterServer()
}

// UnimplementedClusterServer must be embedded to have forward compatible implementations.
type UnimplementedClusterServer struct {
}

func (UnimplementedClusterServer) GetAll(*GetAllRequest, Cluster_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedClusterServer) GetById(context.Context, *wrapperspb.StringValue) (*projections.Cluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetById not implemented")
}
func (UnimplementedClusterServer) GetByName(context.Context, *wrapperspb.StringValue) (*projections.Cluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByName not implemented")
}
func (UnimplementedClusterServer) GetBootstrapToken(context.Context, *wrapperspb.StringValue) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBootstrapToken not implemented")
}
func (UnimplementedClusterServer) mustEmbedUnimplementedClusterServer() {}

// UnsafeClusterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClusterServer will
// result in compilation errors.
type UnsafeClusterServer interface {
	mustEmbedUnimplementedClusterServer()
}

func RegisterClusterServer(s grpc.ServiceRegistrar, srv ClusterServer) {
	s.RegisterService(&Cluster_ServiceDesc, srv)
}

func _Cluster_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAllRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterServer).GetAll(m, &clusterGetAllServer{stream})
}

type Cluster_GetAllServer interface {
	Send(*projections.Cluster) error
	grpc.ServerStream
}

type clusterGetAllServer struct {
	grpc.ServerStream
}

func (x *clusterGetAllServer) Send(m *projections.Cluster) error {
	return x.ServerStream.SendMsg(m)
}

func _Cluster_GetById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.Cluster/GetById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetById(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.Cluster/GetByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetByName(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetBootstrapToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetBootstrapToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.Cluster/GetBootstrapToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetBootstrapToken(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

// Cluster_ServiceDesc is the grpc.ServiceDesc for Cluster service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Cluster_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "domain.Cluster",
	HandlerType: (*ClusterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetById",
			Handler:    _Cluster_GetById_Handler,
		},
		{
			MethodName: "GetByName",
			Handler:    _Cluster_GetByName_Handler,
		},
		{
			MethodName: "GetBootstrapToken",
			Handler:    _Cluster_GetBootstrapToken_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _Cluster_GetAll_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/domain/queryhandler_service.proto",
}

// ClusterAccessClient is the client API for ClusterAccess service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClusterAccessClient interface {
	// GetClusterAccessByTenantId returns clusters which the given tenant has access to by it's UUID
	GetClusterAccessByTenantId(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (ClusterAccess_GetClusterAccessByTenantIdClient, error)
	// GetClusterAccessByUserId returns clusters which the given user has access to by it's UUID
	GetClusterAccessByUserId(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (ClusterAccess_GetClusterAccessByUserIdClient, error)
	// GetTenantClusterMappingsByTenantId returns bindings which belong to the given tenant by it's UUID
	GetTenantClusterMappingsByTenantId(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (ClusterAccess_GetTenantClusterMappingsByTenantIdClient, error)
	// GetTenantClusterMappingsByClusterId returns bindings which belong to the given cluster by it's UUID
	GetTenantClusterMappingsByClusterId(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (ClusterAccess_GetTenantClusterMappingsByClusterIdClient, error)
	// GetTenantClusterMappingsByClusterId returns the binding which belongs to the given tenant and cluster by their UUIDs
	GetTenantClusterMappingByTenantAndClusterId(ctx context.Context, in *GetClusterMappingRequest, opts ...grpc.CallOption) (*projections.TenantClusterBinding, error)
}

type clusterAccessClient struct {
	cc grpc.ClientConnInterface
}

func NewClusterAccessClient(cc grpc.ClientConnInterface) ClusterAccessClient {
	return &clusterAccessClient{cc}
}

func (c *clusterAccessClient) GetClusterAccessByTenantId(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (ClusterAccess_GetClusterAccessByTenantIdClient, error) {
	stream, err := c.cc.NewStream(ctx, &ClusterAccess_ServiceDesc.Streams[0], "/domain.ClusterAccess/GetClusterAccessByTenantId", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterAccessGetClusterAccessByTenantIdClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterAccess_GetClusterAccessByTenantIdClient interface {
	Recv() (*projections.Cluster, error)
	grpc.ClientStream
}

type clusterAccessGetClusterAccessByTenantIdClient struct {
	grpc.ClientStream
}

func (x *clusterAccessGetClusterAccessByTenantIdClient) Recv() (*projections.Cluster, error) {
	m := new(projections.Cluster)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterAccessClient) GetClusterAccessByUserId(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (ClusterAccess_GetClusterAccessByUserIdClient, error) {
	stream, err := c.cc.NewStream(ctx, &ClusterAccess_ServiceDesc.Streams[1], "/domain.ClusterAccess/GetClusterAccessByUserId", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterAccessGetClusterAccessByUserIdClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterAccess_GetClusterAccessByUserIdClient interface {
	Recv() (*projections.Cluster, error)
	grpc.ClientStream
}

type clusterAccessGetClusterAccessByUserIdClient struct {
	grpc.ClientStream
}

func (x *clusterAccessGetClusterAccessByUserIdClient) Recv() (*projections.Cluster, error) {
	m := new(projections.Cluster)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterAccessClient) GetTenantClusterMappingsByTenantId(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (ClusterAccess_GetTenantClusterMappingsByTenantIdClient, error) {
	stream, err := c.cc.NewStream(ctx, &ClusterAccess_ServiceDesc.Streams[2], "/domain.ClusterAccess/GetTenantClusterMappingsByTenantId", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterAccessGetTenantClusterMappingsByTenantIdClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterAccess_GetTenantClusterMappingsByTenantIdClient interface {
	Recv() (*projections.TenantClusterBinding, error)
	grpc.ClientStream
}

type clusterAccessGetTenantClusterMappingsByTenantIdClient struct {
	grpc.ClientStream
}

func (x *clusterAccessGetTenantClusterMappingsByTenantIdClient) Recv() (*projections.TenantClusterBinding, error) {
	m := new(projections.TenantClusterBinding)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterAccessClient) GetTenantClusterMappingsByClusterId(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (ClusterAccess_GetTenantClusterMappingsByClusterIdClient, error) {
	stream, err := c.cc.NewStream(ctx, &ClusterAccess_ServiceDesc.Streams[3], "/domain.ClusterAccess/GetTenantClusterMappingsByClusterId", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterAccessGetTenantClusterMappingsByClusterIdClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterAccess_GetTenantClusterMappingsByClusterIdClient interface {
	Recv() (*projections.TenantClusterBinding, error)
	grpc.ClientStream
}

type clusterAccessGetTenantClusterMappingsByClusterIdClient struct {
	grpc.ClientStream
}

func (x *clusterAccessGetTenantClusterMappingsByClusterIdClient) Recv() (*projections.TenantClusterBinding, error) {
	m := new(projections.TenantClusterBinding)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterAccessClient) GetTenantClusterMappingByTenantAndClusterId(ctx context.Context, in *GetClusterMappingRequest, opts ...grpc.CallOption) (*projections.TenantClusterBinding, error) {
	out := new(projections.TenantClusterBinding)
	err := c.cc.Invoke(ctx, "/domain.ClusterAccess/GetTenantClusterMappingByTenantAndClusterId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterAccessServer is the server API for ClusterAccess service.
// All implementations must embed UnimplementedClusterAccessServer
// for forward compatibility
type ClusterAccessServer interface {
	// GetClusterAccessByTenantId returns clusters which the given tenant has access to by it's UUID
	GetClusterAccessByTenantId(*wrapperspb.StringValue, ClusterAccess_GetClusterAccessByTenantIdServer) error
	// GetClusterAccessByUserId returns clusters which the given user has access to by it's UUID
	GetClusterAccessByUserId(*wrapperspb.StringValue, ClusterAccess_GetClusterAccessByUserIdServer) error
	// GetTenantClusterMappingsByTenantId returns bindings which belong to the given tenant by it's UUID
	GetTenantClusterMappingsByTenantId(*wrapperspb.StringValue, ClusterAccess_GetTenantClusterMappingsByTenantIdServer) error
	// GetTenantClusterMappingsByClusterId returns bindings which belong to the given cluster by it's UUID
	GetTenantClusterMappingsByClusterId(*wrapperspb.StringValue, ClusterAccess_GetTenantClusterMappingsByClusterIdServer) error
	// GetTenantClusterMappingsByClusterId returns the binding which belongs to the given tenant and cluster by their UUIDs
	GetTenantClusterMappingByTenantAndClusterId(context.Context, *GetClusterMappingRequest) (*projections.TenantClusterBinding, error)
	mustEmbedUnimplementedClusterAccessServer()
}

// UnimplementedClusterAccessServer must be embedded to have forward compatible implementations.
type UnimplementedClusterAccessServer struct {
}

func (UnimplementedClusterAccessServer) GetClusterAccessByTenantId(*wrapperspb.StringValue, ClusterAccess_GetClusterAccessByTenantIdServer) error {
	return status.Errorf(codes.Unimplemented, "method GetClusterAccessByTenantId not implemented")
}
func (UnimplementedClusterAccessServer) GetClusterAccessByUserId(*wrapperspb.StringValue, ClusterAccess_GetClusterAccessByUserIdServer) error {
	return status.Errorf(codes.Unimplemented, "method GetClusterAccessByUserId not implemented")
}
func (UnimplementedClusterAccessServer) GetTenantClusterMappingsByTenantId(*wrapperspb.StringValue, ClusterAccess_GetTenantClusterMappingsByTenantIdServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTenantClusterMappingsByTenantId not implemented")
}
func (UnimplementedClusterAccessServer) GetTenantClusterMappingsByClusterId(*wrapperspb.StringValue, ClusterAccess_GetTenantClusterMappingsByClusterIdServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTenantClusterMappingsByClusterId not implemented")
}
func (UnimplementedClusterAccessServer) GetTenantClusterMappingByTenantAndClusterId(context.Context, *GetClusterMappingRequest) (*projections.TenantClusterBinding, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTenantClusterMappingByTenantAndClusterId not implemented")
}
func (UnimplementedClusterAccessServer) mustEmbedUnimplementedClusterAccessServer() {}

// UnsafeClusterAccessServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClusterAccessServer will
// result in compilation errors.
type UnsafeClusterAccessServer interface {
	mustEmbedUnimplementedClusterAccessServer()
}

func RegisterClusterAccessServer(s grpc.ServiceRegistrar, srv ClusterAccessServer) {
	s.RegisterService(&ClusterAccess_ServiceDesc, srv)
}

func _ClusterAccess_GetClusterAccessByTenantId_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterAccessServer).GetClusterAccessByTenantId(m, &clusterAccessGetClusterAccessByTenantIdServer{stream})
}

type ClusterAccess_GetClusterAccessByTenantIdServer interface {
	Send(*projections.Cluster) error
	grpc.ServerStream
}

type clusterAccessGetClusterAccessByTenantIdServer struct {
	grpc.ServerStream
}

func (x *clusterAccessGetClusterAccessByTenantIdServer) Send(m *projections.Cluster) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterAccess_GetClusterAccessByUserId_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterAccessServer).GetClusterAccessByUserId(m, &clusterAccessGetClusterAccessByUserIdServer{stream})
}

type ClusterAccess_GetClusterAccessByUserIdServer interface {
	Send(*projections.Cluster) error
	grpc.ServerStream
}

type clusterAccessGetClusterAccessByUserIdServer struct {
	grpc.ServerStream
}

func (x *clusterAccessGetClusterAccessByUserIdServer) Send(m *projections.Cluster) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterAccess_GetTenantClusterMappingsByTenantId_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterAccessServer).GetTenantClusterMappingsByTenantId(m, &clusterAccessGetTenantClusterMappingsByTenantIdServer{stream})
}

type ClusterAccess_GetTenantClusterMappingsByTenantIdServer interface {
	Send(*projections.TenantClusterBinding) error
	grpc.ServerStream
}

type clusterAccessGetTenantClusterMappingsByTenantIdServer struct {
	grpc.ServerStream
}

func (x *clusterAccessGetTenantClusterMappingsByTenantIdServer) Send(m *projections.TenantClusterBinding) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterAccess_GetTenantClusterMappingsByClusterId_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterAccessServer).GetTenantClusterMappingsByClusterId(m, &clusterAccessGetTenantClusterMappingsByClusterIdServer{stream})
}

type ClusterAccess_GetTenantClusterMappingsByClusterIdServer interface {
	Send(*projections.TenantClusterBinding) error
	grpc.ServerStream
}

type clusterAccessGetTenantClusterMappingsByClusterIdServer struct {
	grpc.ServerStream
}

func (x *clusterAccessGetTenantClusterMappingsByClusterIdServer) Send(m *projections.TenantClusterBinding) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterAccess_GetTenantClusterMappingByTenantAndClusterId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAccessServer).GetTenantClusterMappingByTenantAndClusterId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.ClusterAccess/GetTenantClusterMappingByTenantAndClusterId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAccessServer).GetTenantClusterMappingByTenantAndClusterId(ctx, req.(*GetClusterMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClusterAccess_ServiceDesc is the grpc.ServiceDesc for ClusterAccess service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClusterAccess_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "domain.ClusterAccess",
	HandlerType: (*ClusterAccessServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTenantClusterMappingByTenantAndClusterId",
			Handler:    _ClusterAccess_GetTenantClusterMappingByTenantAndClusterId_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetClusterAccessByTenantId",
			Handler:       _ClusterAccess_GetClusterAccessByTenantId_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetClusterAccessByUserId",
			Handler:       _ClusterAccess_GetClusterAccessByUserId_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetTenantClusterMappingsByTenantId",
			Handler:       _ClusterAccess_GetTenantClusterMappingsByTenantId_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetTenantClusterMappingsByClusterId",
			Handler:       _ClusterAccess_GetTenantClusterMappingsByClusterId_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/domain/queryhandler_service.proto",
}

// AuditLogClient is the client API for AuditLog service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuditLogClient interface {
	// GetByDateRange returns human readable events within the specified data range
	GetByDateRange(ctx context.Context, in *GetAuditLogByDateRangeRequest, opts ...grpc.CallOption) (AuditLog_GetByDateRangeClient, error)
	// GetUserActions returns human readable events caused by the given user actions
	GetUserActions(ctx context.Context, in *GetUserActionsRequest, opts ...grpc.CallOption) (AuditLog_GetUserActionsClient, error)
	// GetUsersOverview returns all users, tenants/clusters they belong to, and their roles
	GetUsersOverview(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (AuditLog_GetUsersOverviewClient, error)
}

type auditLogClient struct {
	cc grpc.ClientConnInterface
}

func NewAuditLogClient(cc grpc.ClientConnInterface) AuditLogClient {
	return &auditLogClient{cc}
}

func (c *auditLogClient) GetByDateRange(ctx context.Context, in *GetAuditLogByDateRangeRequest, opts ...grpc.CallOption) (AuditLog_GetByDateRangeClient, error) {
	stream, err := c.cc.NewStream(ctx, &AuditLog_ServiceDesc.Streams[0], "/domain.AuditLog/GetByDateRange", opts...)
	if err != nil {
		return nil, err
	}
	x := &auditLogGetByDateRangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuditLog_GetByDateRangeClient interface {
	Recv() (*audit.HumanReadableEvent, error)
	grpc.ClientStream
}

type auditLogGetByDateRangeClient struct {
	grpc.ClientStream
}

func (x *auditLogGetByDateRangeClient) Recv() (*audit.HumanReadableEvent, error) {
	m := new(audit.HumanReadableEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *auditLogClient) GetUserActions(ctx context.Context, in *GetUserActionsRequest, opts ...grpc.CallOption) (AuditLog_GetUserActionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &AuditLog_ServiceDesc.Streams[1], "/domain.AuditLog/GetUserActions", opts...)
	if err != nil {
		return nil, err
	}
	x := &auditLogGetUserActionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuditLog_GetUserActionsClient interface {
	Recv() (*audit.HumanReadableEvent, error)
	grpc.ClientStream
}

type auditLogGetUserActionsClient struct {
	grpc.ClientStream
}

func (x *auditLogGetUserActionsClient) Recv() (*audit.HumanReadableEvent, error) {
	m := new(audit.HumanReadableEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *auditLogClient) GetUsersOverview(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (AuditLog_GetUsersOverviewClient, error) {
	stream, err := c.cc.NewStream(ctx, &AuditLog_ServiceDesc.Streams[2], "/domain.AuditLog/GetUsersOverview", opts...)
	if err != nil {
		return nil, err
	}
	x := &auditLogGetUsersOverviewClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuditLog_GetUsersOverviewClient interface {
	Recv() (*audit.UserOverview, error)
	grpc.ClientStream
}

type auditLogGetUsersOverviewClient struct {
	grpc.ClientStream
}

func (x *auditLogGetUsersOverviewClient) Recv() (*audit.UserOverview, error) {
	m := new(audit.UserOverview)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AuditLogServer is the server API for AuditLog service.
// All implementations must embed UnimplementedAuditLogServer
// for forward compatibility
type AuditLogServer interface {
	// GetByDateRange returns human readable events within the specified data range
	GetByDateRange(*GetAuditLogByDateRangeRequest, AuditLog_GetByDateRangeServer) error
	// GetUserActions returns human readable events caused by the given user actions
	GetUserActions(*GetUserActionsRequest, AuditLog_GetUserActionsServer) error
	// GetUsersOverview returns all users, tenants/clusters they belong to, and their roles
	GetUsersOverview(*GetAllRequest, AuditLog_GetUsersOverviewServer) error
	mustEmbedUnimplementedAuditLogServer()
}

// UnimplementedAuditLogServer must be embedded to have forward compatible implementations.
type UnimplementedAuditLogServer struct {
}

func (UnimplementedAuditLogServer) GetByDateRange(*GetAuditLogByDateRangeRequest, AuditLog_GetByDateRangeServer) error {
	return status.Errorf(codes.Unimplemented, "method GetByDateRange not implemented")
}
func (UnimplementedAuditLogServer) GetUserActions(*GetUserActionsRequest, AuditLog_GetUserActionsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetUserActions not implemented")
}
func (UnimplementedAuditLogServer) GetUsersOverview(*GetAllRequest, AuditLog_GetUsersOverviewServer) error {
	return status.Errorf(codes.Unimplemented, "method GetUsersOverview not implemented")
}
func (UnimplementedAuditLogServer) mustEmbedUnimplementedAuditLogServer() {}

// UnsafeAuditLogServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuditLogServer will
// result in compilation errors.
type UnsafeAuditLogServer interface {
	mustEmbedUnimplementedAuditLogServer()
}

func RegisterAuditLogServer(s grpc.ServiceRegistrar, srv AuditLogServer) {
	s.RegisterService(&AuditLog_ServiceDesc, srv)
}

func _AuditLog_GetByDateRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAuditLogByDateRangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuditLogServer).GetByDateRange(m, &auditLogGetByDateRangeServer{stream})
}

type AuditLog_GetByDateRangeServer interface {
	Send(*audit.HumanReadableEvent) error
	grpc.ServerStream
}

type auditLogGetByDateRangeServer struct {
	grpc.ServerStream
}

func (x *auditLogGetByDateRangeServer) Send(m *audit.HumanReadableEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _AuditLog_GetUserActions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetUserActionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuditLogServer).GetUserActions(m, &auditLogGetUserActionsServer{stream})
}

type AuditLog_GetUserActionsServer interface {
	Send(*audit.HumanReadableEvent) error
	grpc.ServerStream
}

type auditLogGetUserActionsServer struct {
	grpc.ServerStream
}

func (x *auditLogGetUserActionsServer) Send(m *audit.HumanReadableEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _AuditLog_GetUsersOverview_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAllRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuditLogServer).GetUsersOverview(m, &auditLogGetUsersOverviewServer{stream})
}

type AuditLog_GetUsersOverviewServer interface {
	Send(*audit.UserOverview) error
	grpc.ServerStream
}

type auditLogGetUsersOverviewServer struct {
	grpc.ServerStream
}

func (x *auditLogGetUsersOverviewServer) Send(m *audit.UserOverview) error {
	return x.ServerStream.SendMsg(m)
}

// AuditLog_ServiceDesc is the grpc.ServiceDesc for AuditLog service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuditLog_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "domain.AuditLog",
	HandlerType: (*AuditLogServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetByDateRange",
			Handler:       _AuditLog_GetByDateRange_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserActions",
			Handler:       _AuditLog_GetUserActions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUsersOverview",
			Handler:       _AuditLog_GetUsersOverview_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/domain/queryhandler_service.proto",
}

// CertificateClient is the client API for Certificate service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CertificateClient interface {
	GetCertificate(ctx context.Context, in *GetCertificateRequest, opts ...grpc.CallOption) (*projections.Certificate, error)
}

type certificateClient struct {
	cc grpc.ClientConnInterface
}

func NewCertificateClient(cc grpc.ClientConnInterface) CertificateClient {
	return &certificateClient{cc}
}

func (c *certificateClient) GetCertificate(ctx context.Context, in *GetCertificateRequest, opts ...grpc.CallOption) (*projections.Certificate, error) {
	out := new(projections.Certificate)
	err := c.cc.Invoke(ctx, "/domain.Certificate/GetCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CertificateServer is the server API for Certificate service.
// All implementations must embed UnimplementedCertificateServer
// for forward compatibility
type CertificateServer interface {
	GetCertificate(context.Context, *GetCertificateRequest) (*projections.Certificate, error)
	mustEmbedUnimplementedCertificateServer()
}

// UnimplementedCertificateServer must be embedded to have forward compatible implementations.
type UnimplementedCertificateServer struct {
}

func (UnimplementedCertificateServer) GetCertificate(context.Context, *GetCertificateRequest) (*projections.Certificate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCertificate not implemented")
}
func (UnimplementedCertificateServer) mustEmbedUnimplementedCertificateServer() {}

// UnsafeCertificateServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CertificateServer will
// result in compilation errors.
type UnsafeCertificateServer interface {
	mustEmbedUnimplementedCertificateServer()
}

func RegisterCertificateServer(s grpc.ServiceRegistrar, srv CertificateServer) {
	s.RegisterService(&Certificate_ServiceDesc, srv)
}

func _Certificate_GetCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateServer).GetCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.Certificate/GetCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateServer).GetCertificate(ctx, req.(*GetCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Certificate_ServiceDesc is the grpc.ServiceDesc for Certificate service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Certificate_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "domain.Certificate",
	HandlerType: (*CertificateServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCertificate",
			Handler:    _Certificate_GetCertificate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/domain/queryhandler_service.proto",
}
